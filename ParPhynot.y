-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParPhynot where

import Prelude

import qualified TAC
import qualified Env as E
import qualified TypeSystem as TS
import qualified ErrorsBuilder as Err
import qualified AbsPhynot as Abs
import LexPhynot

}

%name pProgram Program
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pStm Stm
%name pParam Param
%name pListParam ListParam
%name pDim Dim
%name pListDim ListDim
%name pArr Arr
%name pArrEntry ArrEntry
%name pListArrEntry ListArrEntry
%name pLExp LExp
%name pRExp RExp
%name pRExp1 RExp1
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp6 RExp6
%name pListRExp ListRExp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)  }
  '%'        { PT _ (TS _ 2)  }
  '&'        { PT _ (TS _ 3)  }
  '('        { PT _ (TS _ 4)  }
  '()'       { PT _ (TS _ 5)  }
  ')'        { PT _ (TS _ 6)  }
  '*'        { PT _ (TS _ 7)  }
  '+'        { PT _ (TS _ 8)  }
  ','        { PT _ (TS _ 9)  }
  '-'        { PT _ (TS _ 10) }
  '/'        { PT _ (TS _ 11) }
  ';'        { PT _ (TS _ 12) }
  '<'        { PT _ (TS _ 13) }
  '<='       { PT _ (TS _ 14) }
  '='        { PT _ (TS _ 15) }
  '=='       { PT _ (TS _ 16) }
  '>'        { PT _ (TS _ 17) }
  '>='       { PT _ (TS _ 18) }
  'False'    { PT _ (TS _ 19) }
  'None'     { PT _ (TS _ 20) }
  'String'   { PT _ (TS _ 21) }
  'True'     { PT _ (TS _ 22) }
  '['        { PT _ (TS _ 23) }
  ']'        { PT _ (TS _ 24) }
  '^'        { PT _ (TS _ 25) }
  'and'      { PT _ (TS _ 26) }
  'bool'     { PT _ (TS _ 27) }
  'break'    { PT _ (TS _ 28) }
  'char'     { PT _ (TS _ 29) }
  'const'    { PT _ (TS _ 30) }
  'continue' { PT _ (TS _ 31) }
  'def'      { PT _ (TS _ 32) }
  'else'     { PT _ (TS _ 33) }
  'float'    { PT _ (TS _ 34) }
  'if'       { PT _ (TS _ 35) }
  'int'      { PT _ (TS _ 36) }
  'not'      { PT _ (TS _ 37) }
  'or'       { PT _ (TS _ 38) }
  'pass'     { PT _ (TS _ 39) }
  'return'   { PT _ (TS _ 40) }
  'while'    { PT _ (TS _ 41) }
  '{'        { PT _ (TS _ 42) }
  '}'        { PT _ (TS _ 43) }
  L_Ident    { PT _ (TV _)   }
  L_charac   { PT _ (TC _)   }
  L_doubl    { PT _ (TD _)   }
  L_integ    { PT _ (TI _)   }
  L_quoted   { PT _ (TL _)   }

%attributetype {Attr a}
%attribute res { Result }
%attribute attr { a }
%attribute err { [String] }
%attribute env { E.EnvT }
%attribute modifiedEnv { E.EnvT }
%attribute ident { String }
%attribute pos { Posn }
%attribute btype { TS.Type }

%attribute arraytype { TS.Type }
%attribute arraydim { [Int] }
%attribute arraylen { Int }

%attribute funcName { String }
%attribute paramTypes { [TS.Type] }

%attribute addr { TAC.Address }
%attribute listAddr { [TAC.Address] }
%attribute code { [TAC.TAC] }

%attribute state { TAC.State }
%attribute modifiedState { TAC.State }

%attribute brkjmp { TAC.Label }
%attribute cntjmp { TAC.Label }
%%

------------------
-- Basic Types  --
------------------

Ident  : L_Ident 
{ 
  $$.attr = Abs.Ident (tokenText $1);
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.pos = (tokenPosn $1);
}
Char     : L_charac 
{ 
  $$.attr =  read (tokenText $1) :: Char;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.CHAR);

  $$.pos = (tokenPosn $1);
}
Double   : L_doubl  
{ 
  $$.attr = read (tokenText $1) :: Double;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.FLOAT);

  $$.pos = (tokenPosn $1);
}
Integer  : L_integ  
{ 
  $$.attr = read (tokenText $1) :: Integer;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.INT);

  $$.pos = (tokenPosn $1);
}
String   : L_quoted 
{
  $$.attr =  ((\(PT _ (TL s)) -> s) $1);
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.STRING);

  $$.pos = (tokenPosn $1);
}
Boolean   : 'True' 
{ 
  $$.attr = Abs.Boolean_True;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.BOOL);

  $$.pos = (tokenPosn $1);
}
| 'False' 
{ 
  $$.attr = Abs.Boolean_False;
  $$.ident = (tokenText $1);
  $$.err = [];
  
  $$.btype = (TS.Base TS.BOOL);

  $$.pos = (tokenPosn $1);
}

BasicType: 'int' 
{ 
  $$.attr = Abs.BasicType_int;
  $$.btype = TS.Base TS.INT;
}
| 'float'   
{ 
  $$.attr = Abs.BasicType_float;
  $$.btype = TS.Base TS.FLOAT;
}
| 'char'   
{ 
  $$.attr = Abs.BasicType_char;
  $$.btype = TS.Base TS.CHAR;
}
| 'String'   
{ 
  $$.attr = Abs.BasicType_String;
  $$.btype = TS.Base TS.STRING;
}
| 'bool'  
{ 
  $$.attr = Abs.BasicType_bool;
  $$.btype = TS.Base TS.BOOL;
}

-------------------
-- Program Start --
-------------------

Program : ListStm
{ 
  $$.res =  Result (Abs.ProgramStart $1.attr) $1.err $1.code;
  
  $1.env = E.emptyEnv;
  $1.state = (1, 1);
}

ListStm : Stm ';' 
{ 
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;
  $$.err = $1.err;
  
  $$.code = $1.code;

  $1.state = $$.state;
  $$.modifiedState = $1.modifiedState;

  $1.brkjmp = $$.brkjmp;
  $1.cntjmp = $$.cntjmp;
} 
| Stm ';' ListStm 
{ 
  $$.attr = (:) $1.attr $3.attr;
  $1.env = $$.env;
  $3.env = $1.modifiedEnv;
  $$.err = $1.err ++ $3.err;

  $$.code = $1.code ++ $3.code;

  $1.state = $$.state;
  $3.state = $1.modifiedState;
  $$.modifiedState = $3.modifiedState;

  $1.brkjmp = $$.brkjmp;
  $1.cntjmp = $$.cntjmp;
  $3.brkjmp = $$.brkjmp;
  $3.cntjmp = $$.cntjmp;
}

------------------
-- Declarations --
------------------

Stm: BasicType Ident 
{ 
  $$.attr = Abs.VarDeclaration $1.attr $2.attr;
  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $$.btype $$.addr $$.env;
  $$.err = Err.mkDeclErrs $$.env $2.ident (posLineCol $$.pos); 
  $$.ident = $2.ident;
  $$.pos = $2.pos;
  $$.btype = $1.btype;

  $$.addr = (TAC.generateAddr $1.btype ($2.ident ++ "@" ++ show (fst (posLineCol $2.pos))));
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | BasicType Ident '=' RExp 
{ 
  $$.attr = Abs.VarDeclarationInit $1.attr $2.attr $4.attr;
  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $$.btype $$.addr $$.env;
  $$.err = Err.mkDeclInitErrs $$.btype $4.btype $$.env $2.ident (posLineCol $$.pos) ++ $4.err; 
  $$.ident = $2.ident;
  $$.pos = $2.pos;
  $$.btype = $1.btype;
  $4.env = $$.env; 

  $$.addr = (TAC.generateAddr $1.btype ($2.ident ++ "@" ++ show (fst (posLineCol $2.pos))));
  $$.code = $4.code ++ [TAC.TacInstruction (TAC.NullaryOperation $$.addr $4.addr)];

  $$.modifiedState = $4.modifiedState;
  $4.state = $$.state;
}
  | BasicType Ident ListDim 
{  
  $$.attr = Abs.ArrayDeclaration $1.attr $2.attr $3.attr;
  $$.modifiedEnv = E.insertArray $2.ident (posLineCol $$.pos) $$.btype $3.arraydim $$.addr $$.env;
  $$.ident = $2.ident;
  $$.pos = $2.pos;

  $$.btype = (TS.ARRAY $3.btype);
  $3.arraytype = $1.btype;
  $3.env = $$.env;  

  $$.err = Err.mkArrayDeclErrs $$.env $2.ident (posLineCol $$.pos) ++ $3.err;

  $$.addr = (TAC.generateAddr $$.btype ($2.ident ++ "@" ++ show (fst (posLineCol $2.pos))));
  $$.code = TAC.generateArrayEmpty $$.addr $3.arraydim $1.btype;

  $$.modifiedState = $$.state;
}
  | BasicType Ident ListDim '=' RExp 
{ 
  $$.attr = Abs.ArrayDeclarationInit $1.attr $2.attr $3.attr $5.attr; 
  $$.modifiedEnv = E.insertArray $2.ident (posLineCol $$.pos) $$.btype $3.arraydim $$.addr $$.env;
  $$.ident = $2.ident;
  $$.pos = $2.pos;

  $$.btype = (TS.ARRAY $3.btype);
  $3.arraytype = $1.btype;
  $5.env = $$.env; 

  $$.err = if TS.isArray $5.btype
          then Err.mkArrayLenErrs $2.ident $3.arraydim $5.arraydim (posLineCol $$.pos) ++ $5.err
          else Err.mkArrayDeclInitErrs $$.env $2.ident $$.btype $5.btype (posLineCol $$.pos) ++ $5.err; 

  $$.addr = (TAC.generateAddr $$.btype ($2.ident ++ "@" ++ show (fst (posLineCol $2.pos))));
  $$.code = $5.code ++ TAC.generateArray $$.addr $3.arraydim $1.btype $5.listAddr;

  $$.modifiedState = $5.modifiedState;
  $5.state = $$.state;
}
  
  
  | BasicType '*' Ident 
{  
  $$.attr = Abs.PointerDeclaration $1.attr $3.attr;
  $$.modifiedEnv = E.insertVar $3.ident (posLineCol $$.pos) $$.btype $$.addr $$.env;
  $$.err = Err.mkDeclErrs $$.env $3.ident (posLineCol $$.pos); 
  $$.ident = $3.ident;
  $$.pos = $3.pos;
  $$.btype = (TS.POINTER $1.btype);

  $$.addr = (TAC.generateAddr $1.btype ($3.ident ++ "@" ++ show (fst (posLineCol $3.pos))));
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | BasicType '*' Ident '=' RExp 
{  
  $$.attr = Abs.PointerDeclarationInit $1.attr $3.attr $5.attr;
  $$.modifiedEnv = E.insertVar $3.ident (posLineCol $$.pos) $$.btype $$.addr $$.env;
  $$.err = (Err.mkPointerDeclInitErrs $$.btype $5.btype $$.env $3.ident (posLineCol $$.pos)) ++ $5.err;
  $$.ident = $3.ident;
  $$.pos = $3.pos;
  $$.btype = (TS.POINTER $1.btype) ;
  $5.env = $$.env; 

  $$.addr = (TAC.generateAddr $1.btype ($3.ident ++ "@" ++ show (fst (posLineCol $3.pos))));
  $$.code = $5.code ++ [TAC.TacInstruction (TAC.NullaryOperation $$.addr $5.addr)];

  $$.modifiedState = $5.modifiedState;
  $5.state = $$.state;
}
  | 'const' BasicType Ident '=' RExp
{
  $$.attr = Abs.ConstantDeclaration $2.attr $3.attr $5.attr;
  $$.modifiedEnv = E.insertConst $3.ident (posLineCol $3.pos) $2.btype $$.addr $$.env;
  $5.env = $$.env;
  $$.err = if TAC.isTACLit $5.addr
          then (Err.mkConstDeclErrs $2.btype $5.btype $$.env $3.ident (posLineCol $3.pos)) ++ $5.err
          else [Err.mkStringError("Constant can only be initialized with a literal value")(posLineCol $3.pos)] ++ $5.err;
  $$.ident = $2.ident;
  $$.pos = $3.pos;
  $$.btype = $2.btype;

  $$.addr = $5.addr;
  $$.code = [];

  $$.modifiedState = $5.modifiedState;
  $5.state = $$.state;
}

---------------
-- Functions --
---------------

  | BasicType Ident '(' ListParam ')' 
{ 
  $$.attr = Abs.FunctionPrototype $1.attr $2.attr $4.attr; 

  $$.modifiedEnv = E.insertPrototype $2.ident (posLineCol ($2.pos)) $1.btype $4.paramTypes $$.env;
  $4.env = E.insertVar "return" (posLineCol ($2.pos)) ($$.btype) $$.addr $$.env;

  $4.funcName = $2.ident;

  $$.code = [];
  $$.modifiedState = $$.state;

  $$.err = $4.err ++ (Err.mkPrototypeErrs $1.btype $$.env $2.ident $4.paramTypes (posLineCol ($2.pos)));

}
  | BasicType Ident '()' 
{ 
  $$.attr = Abs.FunctionNoParamPrototype $1.attr $2.attr; 
  
  $$.modifiedEnv = E.insertPrototype $2.ident (posLineCol ($2.pos)) $1.btype [] $$.env;

  $$.code = [];
  $$.modifiedState = $$.state;

  $$.err = (Err.mkPrototypeErrs $2.btype $$.env $2.ident [] (posLineCol ($2.pos)));
}
  | 'None' Ident '(' ListParam ')' 
{ 
  $$.attr = Abs.ProcedurePrototype $2.attr $4.attr; 
  
  $$.modifiedEnv = E.insertPrototype $2.ident (posLineCol ($2.pos)) (TS.Base TS.NONE) $4.paramTypes $$.env;
  $4.env = $$.modifiedEnv;

  $4.funcName = $2.ident;

  $$.code = [];
  $$.modifiedState = $$.state;

  $$.err = $4.err ++ (Err.mkPrototypeErrs (TS.Base TS.NONE) $$.env $2.ident $4.paramTypes (posLineCol ($2.pos)));
}
  | 'None' Ident '()' 
{ 
  $$.attr = Abs.ProcedureNoParamPrototype $2.attr; 
  
  $$.modifiedEnv = E.insertPrototype $2.ident (posLineCol ($2.pos)) (TS.Base TS.NONE) [] $$.env;

  $$.code = [];
  $$.modifiedState = $$.state;

  $$.err = (Err.mkPrototypeErrs (TS.Base TS.NONE) $$.env $2.ident [] (posLineCol ($2.pos)));
}
  | 'def' BasicType Ident '(' ListParam ')' '{' ListStm '}' 
{  
  $$.attr = Abs.FunctionDeclaration $2.attr $3.attr $5.attr $8.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) $2.btype $5.paramTypes $$.addr $$.env;
  $8.env = $5.modifiedEnv;
  $5.env = E.insertFunc $3.ident (posLineCol $$.pos) $2.btype $5.paramTypes $$.addr (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) $$.addr $$.env);

  $$.pos = $3.pos;

  $5.funcName = $3.ident;
  $$.btype = $2.btype;

  $$.err = $5.err ++ (Err.mkFuncDeclErrs $2.btype $$.env $3.ident $5.paramTypes (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $8.err $3.ident);

  $$.addr = (TAC.generateAddr $2.btype ($3.ident ++ "@" ++ show (fst (posLineCol $3.pos))));
  $$.code = [TAC.generateFuncDef $$.addr (E.getAllEntitiesInfo $5.modifiedEnv $3.ident)] ++ $8.code ++ [TAC.TacInstruction (TAC.EndFunction)];

  $$.modifiedState = $8.modifiedState;
  $8.state = $$.state;
}
  | 'def' BasicType Ident '()' '{' ListStm '}' 
{  
  $$.attr = Abs.FunctionNoParamDeclaration $2.attr $3.attr $6.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) $2.btype [] $$.addr $$.env;
  $6.env = E.insertFunc $3.ident (posLineCol $$.pos) $2.btype [] $$.addr (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) $$.addr $$.env);

  $$.pos = $3.pos;

  $$.btype = $2.btype;

  $$.err = (Err.mkFuncDeclErrs $2.btype $$.env $3.ident [] (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $6.err $3.ident);

  $$.addr = (TAC.generateAddr $2.btype ($3.ident ++ "@" ++ show (fst (posLineCol $3.pos))));
  $$.code = [TAC.generateFuncDef $$.addr []] ++ $6.code ++ [TAC.TacInstruction (TAC.EndFunction)];

  $$.modifiedState = $6.modifiedState;
  $6.state = $$.state;
}
  | 'def' 'None' Ident '(' ListParam ')' '{' ListStm '}' 
{  
  $$.attr = Abs.ProcedureDeclaration $3.attr $5.attr $8.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) (TS.Base TS.NONE) $5.paramTypes $$.addr $$.env;
  $8.env = $5.modifiedEnv;
  $5.env = E.insertFunc $3.ident (posLineCol $$.pos) (TS.Base TS.NONE) $5.paramTypes $$.addr (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) $$.addr $$.env);

  $$.pos = $3.pos;

  $5.funcName = $3.ident;
  $$.btype = (TS.Base TS.NONE);

  $$.err = $5.err ++ (Err.mkFuncDeclErrs (TS.Base TS.NONE) $$.env $3.ident $5.paramTypes (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $8.err $3.ident);

  $$.addr = (TAC.generateAddr (TS.Base TS.NONE) ($3.ident ++ "@" ++ show (fst (posLineCol $3.pos))));
  $$.code = [TAC.generateFuncDef $$.addr (E.getAllEntitiesInfo $5.modifiedEnv $3.ident)] ++ $8.code ++ [TAC.TacInstruction (TAC.EndFunction)];

  $$.modifiedState = $8.modifiedState;
  $8.state = $$.state;
}
  | 'def' 'None' Ident '()' '{' ListStm '}' 
{ 
  $$.attr = Abs.ProcedureNoParamDeclaration $3.attr $6.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) (TS.Base TS.NONE) [] $$.addr $$.env;
  $6.env = E.insertFunc $3.ident (posLineCol $$.pos) (TS.Base TS.NONE) [] $$.addr (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) $$.addr $$.env);

  $$.pos = $3.pos;

  $$.btype = (TS.Base TS.NONE);

  $$.err = (Err.mkFuncDeclErrs (TS.Base TS.NONE) $$.env $3.ident [] (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $6.err $3.ident);

  $$.addr = (TAC.generateAddr (TS.Base TS.NONE) ($3.ident ++ "@" ++ show (fst (posLineCol $3.pos))));
  $$.code = [TAC.generateFuncDef $$.addr []] ++ $6.code ++ [TAC.TacInstruction (TAC.EndFunction)];

  $$.modifiedState = $6.modifiedState;
  $6.state = $$.state;
}
  | Ident '(' ListRExp ')' 
{ 
  $$.attr = Abs.ProcedureCall $1.attr $3.attr;
  $3.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkProcedureCallErrs $1.ident $3.paramTypes $$.env (posLineCol $1.pos)) ++ $3.err;
  
  $$.code = $3.code ++ TAC.generateProcCall (E.getAddr $1.ident $$.env) (length $3.attr) $3.listAddr;

  $$.modifiedState = $3.modifiedState;
  $3.state = $$.state;
}
  | Ident '()' 
{ 
  $$.attr = Abs.ProcedureCallNoParam $1.attr;
  $$.modifiedEnv = $$.env;
  
  $$.err = (Err.mkProcedureCallErrs $1.ident [] $$.env (posLineCol $1.pos));

  $$.code = TAC.generateProcCall (E.getAddr $1.ident $$.env) 0 [];

  $$.modifiedState = $$.state;
}
  | 'return' RExp 
{  
  $$.attr = Abs.Return $2.attr;
  $$.btype = $2.btype;
  $2.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkReturnErrs $$.env $2.btype ( posLineCol $$.pos)) ++ $2.err;

  $$.pos = (tokenPosn $1);

  $$.code = $2.code ++ [TAC.TacInstruction (TAC.Return $2.addr)];

  $$.modifiedState = $2.modifiedState;
  $2.state = $$.state;
}
  | 'return' 
{ 
  $$.attr = Abs.ReturnNone;
  $$.btype = (TS.Base TS.NONE);
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkReturnErrs $$.env $$.btype ( posLineCol $$.pos));
  $$.pos = (tokenPosn $1);

  $$.code = [TAC.TacInstruction (TAC.ReturnVoid)];

  $$.modifiedState = $$.state;
}

----------------
-- Assignment --
----------------

  | LExp '=' RExp 
{  
  $$.attr = Abs.Assignment $1.attr $3.attr;
  $$.modifiedEnv = $$.env;
  $$.err = if TS.isArray $3.btype 
          then Err.mkArrayLenErrs $1.ident (E.getArrayLength $1.ident $$.env) $3.arraydim (posLineCol $$.pos) ++ $1.err ++ $3.err
          else Err.mkAssignmentErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) ++ $1.err ++ $3.err;
  $$.ident = $1.ident;
  $$.pos = $1.pos;
  $$.btype = TS.sup $1.btype $3.btype;
  
  $3.env = $$.env;
  $1.env = $$.env;

  $$.code = if TS.isArray (E.getArrayType $1.ident $$.env)
          then if TS.isArray $3.btype
              then $3.code ++ TAC.generateArray $1.addr $3.arraydim (TS.getArrayCurrentType $3.btype $3.arraylen) $3.listAddr
              else $3.code ++ [TAC.TacInstruction (TAC.IndexedAssignment $1.addr 
            (TAC.generateLit (TS.Base TS.INT) (TAC.IntVal (toInteger (TAC.mkArrayIndex (TS.getTypeSize $1.btype) $1.arraydim (E.getArrayLength $1.ident $$.env) 0)))) $3.addr)]
          else $3.code ++ [TAC.TacInstruction (TAC.NullaryOperation $1.addr $3.addr)];

  $$.modifiedState = $3.modifiedState;
  $3.state = $$.state;
}

----------------------
-- Sequence Control --
----------------------

  | 'if' RExp '{' ListStm '}' 
{   
  $$.attr = Abs.IfThen $2.attr $4.attr;
  $2.env = $$.env;
  $4.env = $$.env;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkIfErrs $2.btype (posLineCol (tokenPosn $1)) ++ (Err.prettySequenceErr "if then" $4.err) ++ $2.err;

  $$.addr = $2.addr;
  $$.code = $2.code ++ [TAC.TacInstruction (TAC.ConditionalJump $$.addr (TAC.newLabel $$.state))] ++ $4.code ++ [(TAC.LabelledInstruction (TAC.newLabel $$.state) TAC.NoOperation)];

  $$.modifiedState = $4.modifiedState;
  $2.state = TAC.incrementLabel $$.state;
  $4.state = $2.modifiedState;

  $4.brkjmp = $$.brkjmp;
  $4.cntjmp = $$.cntjmp;
}
  | 'if' RExp '{' ListStm '}' 'else' '{' ListStm '}' 
{       
  $$.attr = Abs.IfThenElse $2.attr $4.attr $8.attr;
  $2.env = $$.env;
  $4.env = $$.env;
  $8.env = $$.env;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkIfErrs $2.btype (posLineCol (tokenPosn $1)) ++ (Err.prettySequenceErr "if then" $4.err) ++ (Err.prettySequenceErr "else" $8.err) ++ $2.err;

  $$.addr = $2.addr;
  $$.code = $2.code ++ [TAC.TacInstruction (TAC.ConditionalJump $$.addr (TAC.newLabel $$.state))] ++ $4.code ++ [(TAC.TacInstruction (TAC.UnconditionalJump (TAC.newLabel (TAC.incrementLabel $$.state))))]
    ++ [(TAC.LabelledInstruction (TAC.newLabel $$.state) TAC.NoOperation)] ++ $8.code ++ [(TAC.LabelledInstruction (TAC.newLabel (TAC.incrementLabel $$.state)) TAC.NoOperation)];

  $$.modifiedState = $8.modifiedState;
  $2.state = TAC.incrementLabel (TAC.incrementLabel $$.state);
  $4.state = $2.modifiedState;
  $8.state = $4.modifiedState;

  $4.brkjmp = $$.brkjmp;
  $4.cntjmp = $$.cntjmp;
  $8.brkjmp = $$.brkjmp;
  $8.cntjmp = $$.cntjmp;
}
  | 'while' RExp '{' ListStm '}' 
{   
  $$.attr = Abs.WhileDo $2.attr $4.attr; 
  $2.env = $$.env;
  $4.env = E.insertVar "continue" (posLineCol (tokenPosn $1)) (TS.Base TS.BOOL) $$.addr (E.insertVar("break") (posLineCol (tokenPosn $1)) (TS.Base TS.BOOL) $$.addr $$.env);
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkWhileErrs $2.btype (posLineCol (tokenPosn $1)) ++ (Err.prettySequenceErr "while" $4.err) ++ $2.err; 

  $$.addr = $2.addr;
  $$.code = [(TAC.LabelledInstruction $$.cntjmp TAC.NoOperation)] ++ $2.code ++ [TAC.TacInstruction (TAC.ConditionalJump $$.addr $$.brkjmp)] ++ $4.code ++ [(TAC.TacInstruction (TAC.UnconditionalJump (TAC.newLabel $$.state)))]
    ++ [(TAC.LabelledInstruction (TAC.newLabel (TAC.incrementLabel $$.state)) TAC.NoOperation)];

  $$.modifiedState = $4.modifiedState;
  $2.state = TAC.incrementLabel (TAC.incrementLabel $$.state);
  $4.state = $2.modifiedState;

  $$.brkjmp = (TAC.newLabel (TAC.incrementLabel $$.state));
  $$.cntjmp = TAC.newLabel $$.state;

  $4.brkjmp = $$.brkjmp;
  $4.cntjmp = $$.cntjmp;
}
  | 'break' 
{   
  $$.attr = Abs.Break;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkJumpStatementErrs "break" $$.env (posLineCol $$.pos);
  $$.pos = (tokenPosn $1);

  $$.modifiedState = $$.state;

  $$.code = [TAC.TacInstruction(TAC.UnconditionalJump $$.brkjmp)];
}
  | 'continue' 
{   
  $$.attr = Abs.Continue;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkJumpStatementErrs "continue" $$.env (posLineCol $$.pos);
  $$.pos = (tokenPosn $1);

  $$.modifiedState = $$.state;

  $$.code = [TAC.TacInstruction(TAC.UnconditionalJump $$.cntjmp)];
}
  | 'pass' 
{  
  $$.attr = Abs.Pass;
  $$.modifiedEnv = $$.env;
  $$.err = [];
  $$.pos = (tokenPosn $1);

  $$.code = [];  
  
  $$.modifiedState = $$.state;
}

-------------------------
-- Function Parameters --
-------------------------

ListParam: {- empty -} 
{ 
  $$.attr = []; 
  $$.modifiedEnv = $$.env;
  $$.err = [];

  $$.paramTypes = [];
}
  | Param 
{  
  $$.attr = (:[]) $1.attr; 
  $1.env = $$.env;
  $$.modifiedEnv = $1.modifiedEnv;
  $1.funcName = $$.funcName;
  $$.err = $1.err;

  $$.paramTypes = [$1.btype]; 
}
  | Param ',' ListParam 
{  
  $$.attr = (:) $1.attr $3.attr; 

  $1.env = $$.env;
  $3.env = $1.modifiedEnv;
  $$.modifiedEnv = $3.modifiedEnv;
  $1.funcName = $$.funcName;
  $3.funcName = $$.funcName;

  $$.err = $1.err ++ $3.err;

  $$.paramTypes = $1.btype : $3.paramTypes;
}

Param : BasicType Ident 
{  
  $$.attr = Abs.Parameter $1.attr $2.attr; 

  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $1.btype (TAC.generateAddr $$.btype ($2.ident ++ "@" ++ show (fst (posLineCol $2.pos)))) $$.env;
  $$.pos = $2.pos;

  $$.err = Err.mkParamErrs $2.ident $$.funcName $$.env (posLineCol $$.pos);

  $$.btype = $1.btype;
}

-----------
-- Array --
-----------

Dim : '[' RExp ']' 
{   
  $$.attr = Abs.ArrayDimension $2.attr; 
  $2.env = $$.env;

  $$.err = Err.mkArrayIndexErrs $2.btype (posLineCol $2.pos) ++ $2.err;
  $$.arraylen = if TS.isInt $2.btype 
              then read $2.ident :: Int 
              else 0;

  $$.modifiedState = $2.modifiedState;
  $2.state = $$.state;
}

ListDim : Dim 
{  
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;

  $$.btype = $$.arraytype;
  $$.arraydim = [$1.arraylen];

  $$.err = $1.err;

  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
} 
| Dim ListDim 
{  
  $$.attr = (:) $1.attr $2.attr; 
  $1.env = $$.env;
  $2.env = $$.env;

  $$.btype = (TS.ARRAY $2.btype);
  $$.arraydim = $1.arraylen : $2.arraydim;
  $2.arraytype = $$.arraytype;

  $$.err = $1.err ++ $2.err;

  $$.modifiedState = $2.modifiedState;
  $1.state = $$.state;
  $2.state = $1.modifiedState;
}

Arr : ListArrEntry 
{ 
  $$.attr = Abs.ArrayValues $1.attr;
  $1.env = $$.env;
  $$.btype = $1.arraytype;

  $$.pos = $1.pos;

  $$.err = $1.err;

  $$.arraydim = length $1.attr : $1.arraydim;

  $$.listAddr = $1.listAddr;
  $$.code = $1.code;

  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

ArrEntry : RExp 
{ 
  $$.attr = Abs.ArrayEntry $1.attr;
  $1.env = $$.env;

  $$.err = if TS.isERROR $1.btype 
          then TS.getErrorMessage $1.btype : $1.err
          else $1.err;
  $$.pos = $1.pos;

  $$.arraydim = if TS.isArray $1.btype
                then $1.arraydim
                else [];

  $$.arraytype = $1.btype;

  $$.listAddr = if TS.isArray $1.btype
                then $1.listAddr
                else [$1.addr];
                
  $$.code = $1.code;

  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

ListArrEntry: ArrEntry { 
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;

  $$.err = $1.err;
  $$.pos = $1.pos;

  $$.arraytype = $1.arraytype;

  $$.arraydim = $1.arraydim;

  $$.listAddr = $1.listAddr;
  $$.code = $1.code;

  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
} 
  | ArrEntry ',' ListArrEntry 
{ 
  $$.attr = (:) $1.attr $3.attr;
  $1.env = $$.env;
  $3.env = $$.env;

  $$.err = $1.err ++ $3.err;
  $$.pos = $3.pos;

  $$.arraytype = if TS.isERROR $1.arraytype 
                then $1.arraytype 
                else if TS.isERROR $3.arraytype 
                then $3.arraytype 
                else if $1.arraytype == $3.arraytype 
                then $1.arraytype 
                else Err.mkError ("Array elements must be of the same type: found '" ++ TS.typeToString $1.arraytype ++ "' at " ++ 
                show (posLineCol $1.pos) ++ " and '" ++ TS.typeToString $3.arraytype ++ "' at " ++ show (posLineCol $3.pos))
                (posLineCol $$.pos);

  $$.arraydim = zipWith max $1.arraydim $3.arraydim;

  $$.listAddr = $1.listAddr ++ $3.listAddr;
  $$.code = $1.code ++ $3.code;

  $$.modifiedState = $3.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}

----------------------
-- Left Expressions --
----------------------

LExp: Ident 
{
  $$.attr = Abs.LIdent $1.attr;
  $$.ident = $1.ident;
  $$.btype = if TS.isERROR (E.getVarType $1.ident $$.env)
            then Err.mkError (TS.getErrorMessage (E.getVarType $1.ident $$.env)) (posLineCol $1.pos)
            else E.getVarType $1.ident $$.env;
  $$.pos = $1.pos;

  $$.addr = E.getAddr $1.ident $$.env;

  $$.err = [];
}
  | Ident ListDim 
{  
  $$.attr = Abs.LArray $1.attr $2.attr;
  $$.ident = $1.ident;
  $2.env = $$.env;

  $$.btype = if TS.isERROR (E.getArrayType $1.ident $$.env) 
            then Err.mkError (TS.getErrorMessage (E.getArrayType $1.ident $$.env)) (posLineCol $1.pos)
            else if TS.isERROR (TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim)))
              then Err.mkError ("Array " ++ $$.ident ++" has " ++ show(E.getArrayDim $$.ident $$.env) ++ " dimension/s but there are " ++ show (length($2.arraydim)) ++ " indexes") (posLineCol $1.pos)
              else TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim));
  $$.pos = $1.pos;

  $2.arraytype = (E.getArrayType $1.ident $$.env);

  $$.arraydim = $2.arraydim;

  $$.addr = E.getAddr $1.ident $$.env;

  $$.err = $2.err;

}

-----------------------
-- Right Expressions --
-----------------------

RExp : '[' Arr ']' 
{ 
  $$.attr = Abs.ArrayStructure $2.attr;
  $2.env = $$.env;

  $$.btype = (TS.ARRAY $2.btype);

  $$.pos = $2.pos;

  $$.arraylen = length($2.arraydim);
  $$.arraydim = $2.arraydim;

  $$.err = $2.err;

  $$.listAddr = $2.listAddr;
  $$.code = $2.code;

  $$.modifiedState = $2.modifiedState;
  $2.state = $$.state;
}
  | RExp 'or' RExp1 
{   
  $$.attr = Abs.Or $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkBoolRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "or")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL;
  $1.env = $$.env;  
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Or))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp 'and' RExp1 
{   
  $$.attr = Abs.And $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkBoolRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "and")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL;
  $1.env = $$.env;  
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.And))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | 'not' RExp1 
{  
  $$.attr = Abs.Not $2.attr;
  $$.err =  (Err.mkNotErrs $2.btype (posLineCol $$.pos)) ++ $2.err;
  $$.btype = TS.Base TS.BOOL;
  $2.env = $$.env; 

  $$.pos = (tokenPosn $1); 

  $$.addr = TAC.newtemp $2.modifiedState $$.btype;
  $$.code = $2.code ++ [TAC.TacInstruction (TAC.UnaryOperation $$.addr $2.addr (TAC.Not))];

  $$.modifiedState = TAC.incrementTemp $2.modifiedState;
  $2.state = $$.state;
}
  | RExp1 
{  
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;

  $$.pos = $1.pos;

  $$.addr = $1.addr;
  $$.code = $1.code;

  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

RExp1 : RExp1 '==' RExp2 
{  
  $$.attr = Abs.Eq $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "==")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType (TS.sup $1.btype $3.btype)) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp (TS.sup $1.btype $3.btype) TAC.Eq))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp1 '!=' RExp2 
{    
  $$.attr = Abs.Neq $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "!=")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType (TS.sup $1.btype $3.btype)) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp (TS.sup $1.btype $3.btype) TAC.Ne))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp1 '<' RExp2 
{    
  $$.attr = Abs.Lt $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "<")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType (TS.sup $1.btype $3.btype)) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp (TS.sup $1.btype $3.btype) TAC.Lt))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp1 '>' RExp2 
{     
  $$.attr = Abs.Gt $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) ">")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType (TS.sup $1.btype $3.btype)) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp (TS.sup $1.btype $3.btype) TAC.Gt))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp1 '<=' RExp2 
{    
  $$.attr = Abs.Le $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "<=")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType (TS.sup $1.btype $3.btype)) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp (TS.sup $1.btype $3.btype) TAC.Le))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp1 '>=' RExp2 
{      
  $$.attr = Abs.Ge $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) ">=")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
  
  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType (TS.sup $1.btype $3.btype)) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp (TS.sup $1.btype $3.btype) TAC.Ge))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp2 
{ 
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = $1.addr;
  $$.code = $1.code;  
  
  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

RExp2 : RExp2 '+' RExp3 
{  
  $$.attr = Abs.Add $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "+")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Add))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp2 '-' RExp3 
{   
  $$.attr = Abs.Sub $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "-")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Sub))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp3 
{
  $$.attr = $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = $1.addr;
  $$.code = $1.code;  
  
  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

RExp3 : RExp3 '*' RExp4 
{
  $$.attr = Abs.Mul $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "*")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Mul))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp3 '/' RExp4 
{ 
  $$.attr = Abs.Div $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "/")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Div))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp3 '%' RExp4 
{    
  $$.attr = Abs.Mod $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "%")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Mod))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}
  | RExp4 
{    
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = $1.addr;
  $$.code = $1.code;  
  
  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

RExp4 : RExp4 '^' RExp5 
{ 
  $$.attr = Abs.Pow $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "^")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);

  $$.addr = TAC.newtemp $1.modifiedState $$.btype;
  $$.code = $1.code ++ $3.code ++ [TAC.TacInstruction (TAC.BinaryOperation (TAC.toTacType $$.btype) $$.addr $1.addr $3.addr (TAC.toTypedBinaryOp $$.btype TAC.Exp))];

  $$.modifiedState = TAC.incrementTemp $1.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
} 
  | RExp5 
{ 
  $$.attr = $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = $1.addr;
  $$.code = $1.code;  
  
  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

RExp5 : '&' RExp6 
{     
  $$.attr = Abs.PointerRef $2.attr; 
  $2.env = $$.env;

  $$.err = $2.err;
  $$.btype = if TS.isERROR $2.btype
            then $2.btype
            else (TS.ADDRESS $2.btype);
            
  $$.pos = $2.pos;

  $$.addr = TAC.newtemp $2.modifiedState $$.btype;
  $$.code = $2.code ++ [TAC.TacInstruction (TAC.UnaryOperation $$.addr $2.addr (TAC.Ref))];

  $$.modifiedState = TAC.incrementTemp $2.modifiedState;
  $2.state = $$.state;
} 
  | '*' RExp6 
{ 
  $$.attr = Abs.DereferenceVal $2.attr;
  $2.env = $$.env;

  $$.err = $2.err;
  $$.btype = if TS.isERROR (TS.getDereferencedType $2.btype)
            then Err.mkError ("Dereference operation require a pointer value, found: " ++ TS.typeToString $2.btype) (posLineCol $$.pos)
            else TS.getDereferencedType $2.btype;

  $$.pos = $2.pos;

  $$.addr = TAC.newtemp $2.modifiedState $$.btype;
  $$.code = $2.code ++ [TAC.TacInstruction (TAC.UnaryOperation $$.addr $2.addr (TAC.Deref))];

  $$.modifiedState = TAC.incrementTemp $2.modifiedState;
  $2.state = $$.state;
}
  | '-' RExp6 
{ 
  $$.attr = Abs.Neg $2.attr; 
  $2.env = $$.env;

  $$.err = $2.err;
  $$.btype = TS.mathtype $2.btype;

  $$.pos = $2.pos; 

  $$.addr = TAC.newtemp $2.modifiedState $$.btype;
  $$.code = $2.code ++ [TAC.TacInstruction (TAC.UnaryOperation $$.addr $2.addr (TAC.Neg))];

  $$.modifiedState = TAC.incrementTemp $2.modifiedState;
  $2.state = $$.state;
}
  | RExp6
{ 
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = $1.addr;
  $$.code = $1.code;  
  
  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}

RExp6 : Integer 
{ 
  $$.attr = Abs.IntValue $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = TAC.generateLit $$.btype (TAC.IntVal $1.attr);
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | Double 
{ 
  $$.attr = Abs.FloatValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = TAC.generateLit $$.btype (TAC.DoubleVal $1.attr);
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | String 
{     
  $$.attr = Abs.StringValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype; 

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = TAC.generateLit $$.btype (TAC.StringVal $1.attr);
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | Char 
{  
  $$.attr = Abs.CharValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = TAC.generateLit $$.btype (TAC.CharVal $1.attr);
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | Boolean 
{  
  $$.attr = Abs.BooleanValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;

  $$.addr = if $1.attr == Abs.Boolean_True
            then TAC.generateLit $$.btype (TAC.BoolVal True)
            else TAC.generateLit $$.btype (TAC.BoolVal False);
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | Ident 
{ 
  $$.attr = Abs.VarValue $1.attr;
  $$.err = $1.err;

  $$.btype = if TS.isERROR (E.getVarType $1.ident $$.env)
            then Err.mkError (TS.getErrorMessage (E.getVarType $1.ident $$.env)) (posLineCol $$.pos)
            else (E.getVarType $1.ident $$.env);

  $$.pos = $1.pos;

  $$.addr = E.getAddr $1.ident $$.env;
  $$.code = [];

  $$.modifiedState = $$.state;
}
  | Ident ListDim 
{ 
  $$.attr = Abs.ArrayIndexValue $1.attr $2.attr; 
  $$.ident = $1.ident;
  $2.env = $$.env;

  $$.btype = if TS.isERROR (E.getArrayType $1.ident $$.env) 
            then Err.mkError (TS.getErrorMessage (E.getArrayType $1.ident $$.env)) (posLineCol $1.pos)
            else if TS.isERROR (TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim)))
              then Err.mkError ("Array " ++ $$.ident ++" has " ++ show(E.getArrayDim $$.ident $$.env) ++ " dimension/s but there are " ++ show (length($2.arraydim)) ++ " indexes") (posLineCol $1.pos)
              else TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim));


  $2.arraytype = (E.getArrayType $1.ident $$.env);

  $$.err = $2.err;
  $$.pos = $1.pos;

  $$.addr = TAC.newtemp $2.modifiedState $$.btype;
  $$.code = [TAC.TacInstruction (TAC.IndexedCopyAssignment $$.addr (E.getAddr $1.ident $$.env) (TAC.generateLit (TS.Base TS.INT) 
    (TAC.IntVal (toInteger (TAC.mkArrayIndex (TS.getTypeSize (TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (E.getArrayDim $1.ident $$.env))) 
    $2.arraydim (E.getArrayLength $1.ident $$.env) 0)))))];

  $$.modifiedState = TAC.incrementTemp $2.modifiedState;
  $2.state = $$.state;
}
  | Ident '(' ListRExp ')' 
{  
  $$.attr = Abs.FuncCall $1.attr $3.attr;
  $3.env = $$.env;

  $$.btype = (E.getFuncType $1.ident $$.env);
  $$.err = (Err.mkFuncCallErrs $1.ident $3.paramTypes $$.env (posLineCol $1.pos)) ++ $3.err;

  $$.pos = $1.pos;

  $$.addr = TAC.newtemp $$.state $$.btype;
  $$.code = $3.code ++ TAC.generateFuncCall $$.addr (E.getAddr $1.ident $$.env) (length $3.attr) $3.listAddr;

  $$.modifiedState = TAC.incrementTemp $3.modifiedState;
  $3.state = $$.state;
}
  | Ident '()' 
{  
  $$.attr = Abs.FuncCallNoParam $1.attr;

  $$.btype = (E.getFuncType $1.ident $$.env);
  $$.err = (Err.mkFuncCallErrs $1.ident [] $$.env (posLineCol $1.pos));

  $$.pos = $1.pos;

  $$.addr = TAC.newtemp $$.state $$.btype;
  $$.code = TAC.generateFuncCall $$.addr (E.getAddr $1.ident $$.env) 0 [];

  $$.modifiedState = TAC.incrementTemp $$.state;
}
  | '(' RExp ')'  
{ 
  $$.attr =  $2.attr;
  $$.err = $2.err;
  $$.btype = $2.btype;
  $2.env = $$.env;

  $$.pos = $2.pos;

  $$.addr = $2.addr;
  $$.code = $2.code;

  $$.modifiedState = $2.modifiedState;
  $2.state = $$.state;
}

ListRExp : {- empty -} 
{ 
  $$.attr = [];

  $$.err = [];
  $$.paramTypes = [];

  $3.listAddr = [];
}
  | RExp 
{    
  $$.attr = (:[]) $1.attr; 
  $1.env = $$.env;

  $$.err = $1.err;
  $$.paramTypes = [$1.btype]; 

  $$.addr = $1.addr;
  $$.listAddr = [$1.addr];
  $$.code = $1.code;

  $$.modifiedState = $1.modifiedState;
  $1.state = $$.state;
}
  | RExp ',' ListRExp 
{  
  $$.attr = (:) $1.attr $3.attr; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.err = $1.err ++ $3.err;
  $$.paramTypes = $1.btype : $3.paramTypes;

  $$.addr = $1.addr;
  $$.listAddr = $1.addr : $3.listAddr;
  $$.code = $1.code ++ $3.code;

  $$.modifiedState = $3.modifiedState;
  $1.state = $$.state;
  $3.state = $1.modifiedState;
}

{

data Result = Result Abs.Program [String] [TAC.TAC]

type Err = Either String

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}