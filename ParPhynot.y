-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParPhynot where

import Prelude

import qualified Env as E
import qualified TypeSystem as TS
import qualified ErrorsBuilder as Err
import qualified AbsPhynot as Abs
import LexPhynot

}

%name pProgram Program
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pStm Stm
%name pListParam ListParam
%name pParam Param
%name pLExp LExp
%name pDim Dim
%name pListDim ListDim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pListRExp ListRExp
%name pRExp1 RExp1
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='          { PT _ (TS _ 1)  }
  '%'           { PT _ (TS _ 2)  }
  '&'           { PT _ (TS _ 3)  }
  '('           { PT _ (TS _ 4)  }
  '()'          { PT _ (TS _ 5)  }
  ')'           { PT _ (TS _ 6)  }
  '*'           { PT _ (TS _ 7)  }
  '+'           { PT _ (TS _ 8)  }
  ','           { PT _ (TS _ 9)  }
  '-'           { PT _ (TS _ 10) }
  '/'           { PT _ (TS _ 11) }
  ';'           { PT _ (TS _ 12) }
  '<'           { PT _ (TS _ 13) }
  '<='          { PT _ (TS _ 14) }
  '='           { PT _ (TS _ 15) }
  '=='          { PT _ (TS _ 16) }
  '>'           { PT _ (TS _ 17) }
  '>='          { PT _ (TS _ 18) }
  'False'       { PT _ (TS _ 19) }
  'None'        { PT _ (TS _ 20) }
  'String'      { PT _ (TS _ 21) }
  'True'        { PT _ (TS _ 22) }
  '['           { PT _ (TS _ 23) }
  ']'           { PT _ (TS _ 24) }
  'and'         { PT _ (TS _ 25) }
  'bool'        { PT _ (TS _ 26) }
  'break'       { PT _ (TS _ 27) }
  'char'        { PT _ (TS _ 28) }
  'continue'    { PT _ (TS _ 29) }
  'def'         { PT _ (TS _ 30) }
  'else'        { PT _ (TS _ 31) }
  'float'       { PT _ (TS _ 32) }
  'if'          { PT _ (TS _ 33) }
  'int'         { PT _ (TS _ 34) }
  'not'         { PT _ (TS _ 35) }
  'or'          { PT _ (TS _ 36) }
  'pass'        { PT _ (TS _ 37) }
  'readChar'    { PT _ (TS _ 38) }
  'readFloat'   { PT _ (TS _ 39) }
  'readInt'     { PT _ (TS _ 40) }
  'readString'  { PT _ (TS _ 41) }
  'return'      { PT _ (TS _ 42) }
  'while'       { PT _ (TS _ 43) }
  'writeChar'   { PT _ (TS _ 44) }
  'writeFloat'  { PT _ (TS _ 45) }
  'writeInt'    { PT _ (TS _ 46) }
  'writeString' { PT _ (TS _ 47) }
  '{'           { PT _ (TS _ 48) }
  '}'           { PT _ (TS _ 49) }
  L_Ident       { PT _ (TV _)    }
  L_charac      { PT _ (TC _)    }
  L_doubl       { PT _ (TD _)   }
  L_integ       { PT _ (TI _)   }
  L_quoted      { PT _ (TL _)   }

%attributetype {Attr a}
%attribute res { Result }
%attribute attr { a }
%attribute err { [String] }
%attribute env { E.EnvT }
%attribute modifiedEnv { E.EnvT }
%attribute ident { String }
%attribute pos { Posn }
%attribute btype { TS.Type }

%attribute arraytype { TS.Type }
%attribute arraydim { [Int] }
%attribute arraylen { Int }

%attribute funcName { String }
%attribute paramTypes { [TS.Type] }

%%

------------------
-- Basic Types  --
------------------

Ident  : L_Ident 
{ 
  $$.attr = Abs.Ident (tokenText $1);
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.pos = (tokenPosn $1);
}
Char     : L_charac 
{ 
  $$.attr =  read (tokenText $1) :: Char;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.CHAR);

  $$.pos = (tokenPosn $1);
}
Double   : L_doubl  
{ 
  $$.attr = read (tokenText $1) :: Double;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.FLOAT);

  $$.pos = (tokenPosn $1);
}
Integer  : L_integ  
{ 
  $$.attr = read (tokenText $1) :: Integer;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.INT);

  $$.pos = (tokenPosn $1);
}
String   : L_quoted 
{
  $$.attr =  ((\(PT _ (TL s)) -> s) $1);
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.STRING);

  $$.pos = (tokenPosn $1);
}
Boolean   : 'True' 
{ 
  $$.attr = Abs.Boolean_True;
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.btype = (TS.Base TS.BOOL);

  $$.pos = (tokenPosn $1);
}
| 'False' 
{ 
  $$.attr = Abs.Boolean_False;
  $$.ident = (tokenText $1);
  $$.err = [];
  
  $$.btype = (TS.Base TS.BOOL);

  $$.pos = (tokenPosn $1);
}

BasicType: 'int' 
{ 
  $$.attr = Abs.BasicType_int;
  $$.btype = TS.Base TS.INT;
}
| 'float'   
{ 
  $$.attr = Abs.BasicType_float;
  $$.btype = TS.Base TS.FLOAT;
}
| 'char'   
{ 
  $$.attr = Abs.BasicType_char;
  $$.btype = TS.Base TS.CHAR;
}
| 'String'   
{ 
  $$.attr = Abs.BasicType_String;
  $$.btype = TS.Base TS.STRING;
}
| 'bool'  
{ 
  $$.attr = Abs.BasicType_bool;
  $$.btype = TS.Base TS.BOOL;
}

-------------------
-- Program Start --
-------------------

Program : ListStm 
{ 
  $$.res = Result (Abs.ProgramStart $1.attr) $1.err;
  $1.env = E.emptyEnv;
}

ListStm : Stm ';' 
{ 
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;
  $$.err = $1.err;
} 
| Stm ';' ListStm 
{ 
  $$.attr = (:) $1.attr $3.attr;
  $1.env = $$.env;
  $3.env = $1.modifiedEnv;
  $$.err = $1.err ++ $3.err;
}

------------------
-- Declarations --
------------------

Stm: BasicType Ident 
{ 
  $$.attr = Abs.VarDeclaration $1.attr $2.attr;
  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkDeclErrs $$.env $2.ident (posLineCol $$.pos); 
  $$.ident = $2.ident;
  $$.pos = $2.pos;
  $$.btype = $1.btype;
}
  | BasicType Ident '=' RExp 
{ 
  $$.attr = Abs.VarDeclarationInit $1.attr $2.attr $4.attr;
  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkDeclInitErrs $$.btype $4.btype $$.env $2.ident (posLineCol $$.pos) ++ $4.err; 
  $$.ident = $2.ident;
  $$.pos = $2.pos;
  $$.btype = $1.btype;
  $4.env = $$.env; 
}
  | BasicType Ident ListDim 
{  
  $$.attr = Abs.ArrayDeclaration $1.attr $2.attr $3.attr;
  $$.modifiedEnv = E.insertArray $2.ident (posLineCol $$.pos) $$.btype $3.arraydim $$.env;
  $$.ident = $2.ident;
  $$.pos = $2.pos;

  $$.btype = (TS.ARRAY $3.btype);
  $3.arraytype = $1.btype;
  $3.env = $$.env;  

  $$.err = Err.mkArrayDeclErrs $$.env $2.ident (posLineCol $$.pos) ++ $3.err;
}
  | BasicType Ident ListDim '=' RExp 
{ 
  $$.attr = Abs.ArrayDeclarationInit $1.attr $2.attr $3.attr $5.attr; 
  $$.modifiedEnv = E.insertArray $2.ident (posLineCol $$.pos) $$.btype $3.arraydim $$.env;
  $$.ident = $2.ident;
  $$.pos = $2.pos;

  $$.btype = (TS.ARRAY $3.btype);
  $3.arraytype = $1.btype;
  $5.env = $$.env; 

  $$.err = if TS.isArray $5.btype
          then Err.mkArrayLenErrs $2.ident $3.arraydim $5.arraydim (posLineCol $$.pos)
          ++ $5.err
          else Err.mkArrayDeclInitErrs $$.env $2.ident $$.btype $5.btype (posLineCol $$.pos) ++ $5.err; 
}
  
  
  | BasicType '*' Ident 
{  
  $$.attr = Abs.PointerDeclaration $1.attr $3.attr;
  $$.modifiedEnv = E.insertVar $3.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkDeclErrs $$.env $3.ident (posLineCol $$.pos); 
  $$.ident = $3.ident;
  $$.pos = $3.pos;
  $$.btype = (TS.POINTER $1.btype);
}
  | BasicType '*' Ident '=' RExp 
{  
  $$.attr = Abs.PointerDeclarationInit $1.attr $3.attr $5.attr;
  $$.modifiedEnv = E.insertVar $3.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = (Err.mkPointerDeclInitErrs $$.btype $5.btype $$.env $3.ident (posLineCol $$.pos)) ++ $5.err;
  $$.ident = $3.ident;
  $$.pos = $3.pos;
  $$.btype = (TS.POINTER $1.btype) ;
  $5.env = $$.env; 
}

---------------
-- Functions --
---------------

  | 'def' BasicType Ident '(' ListParam ')' '{' ListStm '}' 
{  
  $$.attr = Abs.FunctionDeclaration $2.attr $3.attr $5.attr $8.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) $2.btype $5.paramTypes $$.env;
  $8.env = $5.modifiedEnv;
  $5.env = E.insertFunc $3.ident (posLineCol $$.pos) $2.btype $5.paramTypes (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $5.funcName = $3.ident;
  $$.btype = $2.btype;

  $$.err = $5.err ++ (Err.mkFuncDeclErrs $2.btype $$.env $3.ident $5.paramTypes (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $8.err $3.ident);
}
  | 'def' BasicType Ident '()' '{' ListStm '}' 
{  
  $$.attr = Abs.FunctionNoParamDeclaration $2.attr $3.attr $6.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) $2.btype [] $$.env;
  $6.env = E.insertFunc $3.ident (posLineCol $$.pos) $2.btype [] (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $$.btype = $2.btype;

  $$.err = (Err.mkFuncDeclErrs $2.btype $$.env $3.ident [] (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $6.err $3.ident);
}
  | 'def' 'None' Ident '(' ListParam ')' '{' ListStm '}' 
{  
  $$.attr = Abs.ProcedureDeclaration $3.attr $5.attr $8.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) (TS.Base TS.NONE) $5.paramTypes $$.env;
  $8.env = $5.modifiedEnv;
  $5.env = E.insertFunc $3.ident (posLineCol $$.pos) (TS.Base TS.NONE) $5.paramTypes (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $5.funcName = $3.ident;
  $$.btype = (TS.Base TS.NONE);

  $$.err = $5.err ++ (Err.mkFuncDeclErrs (TS.Base TS.NONE) $$.env $3.ident $5.paramTypes (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $8.err $3.ident);
}
  | 'def' 'None' Ident '()' '{' ListStm '}' 
{ 
  $$.attr = Abs.ProcedureNoParamDeclaration $3.attr $6.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) (TS.Base TS.NONE) [] $$.env;
  $6.env = E.insertFunc $3.ident (posLineCol $$.pos) (TS.Base TS.NONE) [] (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $$.btype = (TS.Base TS.NONE);

  $$.err = (Err.mkFuncDeclErrs (TS.Base TS.NONE) $$.env $3.ident [] (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $6.err $3.ident);
}
  | Ident '(' ListRExp ')' 
{ 
  $$.attr = Abs.ProcedureCall $1.attr $3.attr;
  $3.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkProcedureCallErrs $1.ident $3.paramTypes $$.env (posLineCol $1.pos)) ++ $3.err;
}
  | Ident '()' 
{ 
  $$.attr = Abs.ProcedureCallNoParam $1.attr;
  $$.modifiedEnv = $$.env;
  
  $$.err = (Err.mkProcedureCallErrs $1.ident [] $$.env (posLineCol $1.pos));
}
  | 'return' RExp 
{  
  $$.attr = Abs.Return $2.attr;
  $$.btype = $2.btype;
  $2.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkReturnErrs $$.env $2.btype ( posLineCol $$.pos)) ++ $2.err;

  $$.pos = (tokenPosn $1);
}
  | 'return' 
{ 
  $$.attr = Abs.ReturnNone;
  $$.btype = (TS.Base TS.NONE);
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkReturnErrs $$.env $$.btype ( posLineCol $$.pos));
  $$.pos = (tokenPosn $1);
}

----------------
-- Assignment --
----------------

  | LExp '=' RExp 
{  
  $$.attr = Abs.Assignment $1.attr $3.attr;
  $$.modifiedEnv = $$.env;
  $$.err = if TS.isArray $3.btype 
          then Err.mkArrayLenErrs $1.ident (E.getArrayLength $1.ident $$.env) $3.arraydim (posLineCol $$.pos) ++ $1.err ++ $3.err
          else Err.mkAssignmentErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) ++ $1.err ++ $3.err;
  $$.ident = $1.ident;
  $$.pos = $1.pos;
  $$.btype = TS.sup $1.btype $3.btype;
  
  $3.env = $$.env;
  $1.env = $$.env;
}

-----------------------
-- Default Functions --
-----------------------

  | 'writeInt' '(' RExp ')' 
{  
  $$.attr = Abs.WriteInt $3.attr;
  $3.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = Err.mkFuncCallErrs "writeInt" [$3.btype] $$.env (posLineCol $$.pos) ++ $3.err;
  $$.pos = (tokenPosn $1);
}
  | 'writeFloat' '(' RExp ')' 
{  
  $$.attr = Abs.WriteFloat $3.attr;
  $3.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = Err.mkFuncCallErrs "writeFloat" [$3.btype] $$.env (posLineCol $$.pos) ++ $3.err;
  $$.pos = (tokenPosn $1);
}
  | 'writeChar' '(' RExp ')' 
{   
  $$.attr = Abs.WriteChar $3.attr;
  $3.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = Err.mkFuncCallErrs "writeChar" [$3.btype] $$.env (posLineCol $$.pos) ++ $3.err;
  $$.pos = (tokenPosn $1);
}
  | 'writeString' '(' RExp ')' 
{   
  $$.attr = Abs.WriteString $3.attr;
  $3.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = Err.mkFuncCallErrs "writeString" [$3.btype] $$.env (posLineCol $$.pos) ++ $3.err;
  $$.pos = (tokenPosn $1);
}
  | 'readInt' '()' 
{  
  $$.attr = Abs.ReadInt;
  $$.modifiedEnv = $$.env;
  $$.pos = (tokenPosn $1);

  $$.btype = (TS.Base TS.INT);

  $$.err = [];
}
  | 'readFloat' '()' 
{  
  $$.attr = Abs.ReadFloat;
  $$.modifiedEnv = $$.env;
  $$.pos = (tokenPosn $1);

  $$.btype = (TS.Base TS.FLOAT);

  $$.err = []; 
}
  | 'readChar' '()' 
{  
  $$.attr = Abs.ReadChar;
  $$.modifiedEnv = $$.env;
  $$.pos = (tokenPosn $1);

  $$.btype = (TS.Base TS.CHAR);

  $$.err = [];  
}
  | 'readString' '()' 
{   
  $$.attr = Abs.ReadString;
  $$.modifiedEnv = $$.env;
  $$.pos = (tokenPosn $1);

  $$.btype = (TS.Base TS.STRING);

  $$.err = [];
}

----------------------
-- Sequence Control --
----------------------

  | 'if' RExp '{' ListStm '}' 
{   
    $$.attr = Abs.IfThen $2.attr $4.attr;
    $2.env = $$.env;
    $4.env = $$.env;
    $$.modifiedEnv = $$.env;
    $$.err = Err.mkIfErrs $2.btype (posLineCol (tokenPosn $1)) ++ (Err.prettySequenceErr "if then" $4.err) ++ $2.err;
}
  | 'if' RExp '{' ListStm '}' 'else' '{' ListStm '}' 
{       
    $$.attr = Abs.IfThenElse $2.attr $4.attr $8.attr;
    $2.env = $$.env;
    $4.env = $$.env;
    $8.env = $$.env;
    $$.modifiedEnv = $$.env;
    $$.err = Err.mkIfErrs $2.btype (posLineCol (tokenPosn $1)) ++ (Err.prettySequenceErr "if then" $4.err) ++ (Err.prettySequenceErr "else" $8.err) ++ $2.err;
}
  | 'while' RExp '{' ListStm '}' 
{   
    $$.attr = Abs.WhileDo $2.attr $4.attr; 
    $2.env = $$.env;
    $4.env = E.insertVar "continue" (posLineCol (tokenPosn $1)) (TS.Base TS.BOOL) (E.insertVar("break") (posLineCol (tokenPosn $1)) (TS.Base TS.BOOL) $$.env);
    $$.modifiedEnv = $$.env;
    $$.err = Err.mkWhileErrs $2.btype (posLineCol (tokenPosn $1)) ++ (Err.prettySequenceErr "while" $4.err) ++ $2.err; 
}
  | 'break' 
{   
  $$.attr = Abs.Break;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkJumpStatementErrs "break" $$.env (posLineCol $$.pos);
  $$.pos = (tokenPosn $1);
}
  | 'continue' 
{   
  $$.attr = Abs.Continue;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkJumpStatementErrs "continue" $$.env (posLineCol $$.pos);
  $$.pos = (tokenPosn $1);
}
  | 'pass' 
{  
  $$.attr = Abs.Pass;
  $$.modifiedEnv = $$.env;
  $$.err = [];
  $$.pos = (tokenPosn $1);
}

-------------------------
-- Function Parameters --
-------------------------

ListParam: {- empty -} 
{ 
  $$.attr = []; 
  $$.modifiedEnv = $$.env;
  $$.err = [];

  $$.paramTypes = [];
}
  | Param 
{  
  $$.attr = (:[]) $1.attr; 
  $1.env = $$.env;
  $$.modifiedEnv = $1.modifiedEnv;
  $1.funcName = $$.funcName;
  $$.err = $1.err;

  $$.paramTypes = [$1.btype]; 
}
  | Param ',' ListParam 
{  
  $$.attr = (:) $1.attr $3.attr; 

  $1.env = $$.env;
  $3.env = $1.modifiedEnv;
  $$.modifiedEnv = $3.modifiedEnv;
  $1.funcName = $$.funcName;
  $3.funcName = $$.funcName;

  $$.err = $1.err ++ $3.err;

  $$.paramTypes = $1.btype : $3.paramTypes;
}

Param : BasicType Ident 
{  
  $$.attr = Abs.Parameter $1.attr $2.attr; 

  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $1.btype $$.env;
  $$.pos = $2.pos;

  $$.err = Err.mkParamErrs $2.ident $$.funcName $$.env (posLineCol $$.pos);

  $$.btype = $1.btype;
}

-----------
-- Array --
-----------

Dim : '[' RExp ']' 
{   
  $$.attr = Abs.ArrayDimension $2.attr; 
  $2.env = $$.env;

  $$.err = Err.mkArrayIndexErrs $2.btype (posLineCol $2.pos) ++ $2.err;
  $$.arraylen = if TS.isInt $2.btype 
              then read $2.ident :: Int 
              else 0;
}

ListDim : Dim 
{  
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;

  $$.btype = $$.arraytype;
  $$.arraydim = [$1.arraylen];

  $$.err = $1.err;
} 
| Dim ListDim 
{  
  $$.attr = (:) $1.attr $2.attr; 
  $1.env = $$.env;
  $2.env = $$.env;

  $$.btype = (TS.ARRAY $2.btype);
  $$.arraydim = $1.arraylen : $2.arraydim;
  $2.arraytype = $$.arraytype;

  $$.err = $1.err ++ $2.err;
}

Arr : ListArrEntry 
{ 
  $$.attr = Abs.ArrayValues $1.attr;
  $1.env = $$.env;
  $$.btype = $1.arraytype;

  $$.pos = $1.pos;

  $$.err = $1.err;

  $$.arraydim = length $1.attr : $1.arraydim;
}

ArrEntry : RExp 
{ 
  $$.attr = Abs.ArrayEntry $1.attr;
  $1.env = $$.env;

  $$.err = if TS.isERROR $1.btype 
          then TS.getErrorMessage $1.btype : $1.err
          else $1.err;
  $$.pos = $1.pos;

  $$.arraydim = if TS.isArray $1.btype
                then $1.arraydim
                else [];

  $$.arraytype = $1.btype;
}

ListArrEntry: ArrEntry { 
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;

  $$.err = $1.err;
  $$.pos = $1.pos;

  $$.arraytype = $1.arraytype;

  $$.arraydim = $1.arraydim;

} 
  | ArrEntry ',' ListArrEntry 
{ 
  $$.attr = (:) $1.attr $3.attr;
  $1.env = $$.env;
  $3.env = $$.env;

  $$.err = $1.err ++ $3.err;
  $$.pos = $3.pos;

  $$.arraytype = if TS.isERROR $1.arraytype 
                then $1.arraytype 
                else if TS.isERROR $3.arraytype 
                then $3.arraytype 
                else if $1.arraytype == $3.arraytype 
                then $1.arraytype 
                else Err.mkError ("Array elements must be of the same type: found '" ++ TS.typeToString $1.arraytype ++ "' at " ++ 
                show (posLineCol $1.pos) ++ " and '" ++ TS.typeToString $3.arraytype ++ "' at " ++ show (posLineCol $3.pos))
                (posLineCol $$.pos);

  $$.arraydim = zipWith max $1.arraydim $3.arraydim;

}

----------------------
-- Left Expressions --
----------------------

LExp: Ident 
{
  $$.attr = Abs.LIdent $1.attr;
  $$.ident = $1.ident;
  $$.btype = if TS.isERROR (E.getVarType $1.ident $$.env)
            then Err.mkError (TS.getErrorMessage (E.getVarType $1.ident $$.env)) (posLineCol $1.pos)
            else E.getVarType $1.ident $$.env;
  $$.pos = $1.pos;

  $$.err = [];
}
  | Ident ListDim 
{  
  $$.attr = Abs.LArray $1.attr $2.attr;
  $$.ident = $1.ident;
  $2.env = $$.env;

  $$.btype = if TS.isERROR (E.getArrayType $1.ident $$.env) 
            then Err.mkError (TS.getErrorMessage (E.getArrayType $1.ident $$.env)) (posLineCol $1.pos)
            else if TS.isERROR (TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim)))
              then Err.mkError ("Array " ++ $$.ident ++" has " ++ show(E.getArrayDim $$.ident $$.env) ++ " dimension/s but there are " ++ show (length($2.arraydim)) ++ " indexes") (posLineCol $1.pos)
              else TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim));

  $2.arraytype = (E.getArrayType $1.ident $$.env);

  $$.err = $2.err;
  $$.pos = $1.pos;
}

-----------------------
-- Right Expressions --
-----------------------

RExp : '[' Arr ']' 
{ 
  $$.attr = Abs.ArrayStructure $2.attr;
  $2.env = $$.env;

  $$.btype = (TS.ARRAY $2.btype);

  $$.pos = $2.pos;

  $$.arraylen = length($2.arraydim);
  $$.arraydim = $2.arraydim;

  $$.err = $2.err;
}
  | RExp 'or' RExp2 
{   
  $$.attr = Abs.Or $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkBoolRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "or")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL;
  $1.env = $$.env;  
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | RExp 'and' RExp2 
{   
  $$.attr = Abs.And $1.attr $3.attr;
  $$.err = (Err.prettyRelErr (Err.mkBoolRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "and")  ++ $1.err ++ $3.err;
  $$.btype = TS.Base TS.BOOL;
  $1.env = $$.env;  
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | 'not' RExp2 
{  
  $$.attr = Abs.Not $2.attr;
  $$.err =  (Err.mkNotErrs $2.btype (posLineCol $$.pos)) ++ $2.err;
  $$.btype = TS.Base TS.BOOL;
  $2.env = $$.env; 

  $$.pos = (tokenPosn $1); 
}
  | RExp1 
{  
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;

  $$.pos = $1.pos;
}

RExp2
  : RExp2 '==' RExp3 
{  
    $$.attr = Abs.Eq $1.attr $3.attr;
    $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "==")  ++ $1.err ++ $3.err;
    $$.btype = TS.Base TS.BOOL; 
    $1.env = $$.env;
    $3.env = $$.env;

    $$.pos = (tokenPosn $2);
}
  | RExp2 '!=' RExp3 
{    
    $$.attr = Abs.Neq $1.attr $3.attr;
    $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "!=")  ++ $1.err ++ $3.err;
    $$.btype = TS.Base TS.BOOL; 
    $1.env = $$.env;
    $3.env = $$.env;

    $$.pos = (tokenPosn $2);
}
  | RExp2 '<' RExp3 
{    
    $$.attr = Abs.Lt $1.attr $3.attr;
    $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "<")  ++ $1.err ++ $3.err;
    $$.btype = TS.Base TS.BOOL; 
    $1.env = $$.env;
    $3.env = $$.env;

    $$.pos = (tokenPosn $2);
}
  | RExp2 '>' RExp3 
{     
    $$.attr = Abs.Gt $1.attr $3.attr;
    $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) ">")  ++ $1.err ++ $3.err;
    $$.btype = TS.Base TS.BOOL; 
    $1.env = $$.env;
    $3.env = $$.env;

    $$.pos = (tokenPosn $2);
}
  | RExp2 '<=' RExp3 
{    
    $$.attr = Abs.Le $1.attr $3.attr;
    $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) "<=")  ++ $1.err ++ $3.err;
    $$.btype = TS.Base TS.BOOL; 
    $1.env = $$.env;
    $3.env = $$.env;

    $$.pos = (tokenPosn $2);
}
  | RExp2 '>=' RExp3 
{      
    $$.attr = Abs.Ge $1.attr $3.attr;
    $$.err = (Err.prettyRelErr (Err.mkRelErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos)) ">=")  ++ $1.err ++ $3.err;
    $$.btype = TS.Base TS.BOOL; 
    $1.env = $$.env;
    $3.env = $$.env;

    $$.pos = (tokenPosn $2);
}
  | RExp3 
{ 
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}

RExp3 : RExp3 '+' RExp4 
{  
  $$.attr = Abs.Add $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "+")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | RExp3 '-' RExp4 
{   
  $$.attr = Abs.Sub $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "-")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | RExp3 '*' RExp4 
{     
  $$.attr = Abs.Mul $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "*")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | RExp3 '/' RExp4 
{    
  $$.attr = Abs.Div $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "/")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | RExp3 '%' RExp4 
{    
  $$.attr = Abs.Mod $1.attr $3.attr;
  $$.err = $1.err ++ $3.err;
  $$.btype = if TS.isERROR (TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype))
            then TS.Base  (TS.ERROR (head(Err.mkBinOppErrs  $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) (posLineCol $$.pos) "%")))
            else TS.sup (TS.mathtype $1.btype) (TS.mathtype $3.btype);
  $1.env = $$.env;
  $3.env = $$.env;

  $$.pos = (tokenPosn $2);
}
  | RExp4 
{    
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}

RExp4 : '&' RExp5 
{     
  $$.attr = Abs.PointerRef $2.attr; 
  $2.env = $$.env;

  $$.err = $2.err;
  $$.btype = if TS.isERROR $2.btype
            then $2.btype
            else (TS.ADDRESS $2.btype);
            
  $$.pos = $2.pos;
} 
  | '*' RExp5 
{ 
  $$.attr = Abs.DereferenceVal $2.attr;
  $2.env = $$.env;

  $$.err = $2.err;
  $$.btype = if TS.isERROR (TS.getDereferencedType $2.btype)
            then Err.mkError ("Dereference operation require a pointer value, found: " ++ TS.typeToString $2.btype) (posLineCol $$.pos)
            else TS.getDereferencedType $2.btype;

  $$.pos = $2.pos;
}
  | RExp5 
{ 
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}

RExp5 : Integer 
{ 
  $$.attr = Abs.IntValue $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}
  | Double 
{ 
  $$.attr = Abs.FloatValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}
  | String 
{     
  $$.attr = Abs.StringValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype; 

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}
  | Char 
{  
  $$.attr = Abs.CharValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}
  | Boolean 
{  
  $$.attr = Abs.BooleanValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}
  | Ident 
{ 
  $$.attr = Abs.VarValue $1.attr;
  $$.err = $1.err;

  $$.btype = if TS.isERROR (E.getVarType $1.ident $$.env)
            then Err.mkError (TS.getErrorMessage (E.getVarType $1.ident $$.env)) (posLineCol $$.pos)
            else (E.getVarType $1.ident $$.env);

  $$.pos = $1.pos;
}
  | Ident ListDim 
{ 
  $$.attr = Abs.ArrayIndexValue $1.attr $2.attr; 
  $$.ident = $1.ident;
  $2.env = $$.env;

  $$.btype = if TS.isERROR (E.getArrayType $1.ident $$.env) 
            then Err.mkError (TS.getErrorMessage (E.getArrayType $1.ident $$.env)) (posLineCol $1.pos)
            else if TS.isERROR (TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim)))
              then Err.mkError ("Array " ++ $$.ident ++" has " ++ show(E.getArrayDim $$.ident $$.env) ++ " dimension/s but there are " ++ show (length($2.arraydim)) ++ " indexes") (posLineCol $1.pos)
              else TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) (length($2.arraydim));


  $2.arraytype = (E.getArrayType $1.ident $$.env);

  $$.err = $2.err;
  $$.pos = $1.pos;
}
  | Ident '(' ListRExp ')' 
{  
  $$.attr = Abs.FuncCall $1.attr $3.attr;
  $3.env = $$.env;

  $$.btype = (E.getFuncType $1.ident $$.env);
  $$.err = (Err.mkFuncCallErrs $1.ident $3.paramTypes $$.env (posLineCol $1.pos)) ++ $3.err;

  $$.pos = $1.pos;
}
  | Ident '()' 
{  
  $$.attr = Abs.FuncCallNoParam $1.attr;

  $$.btype = (E.getFuncType $1.ident $$.env);
  $$.err = (Err.mkFuncCallErrs $1.ident [] $$.env (posLineCol $1.pos));

  $$.pos = $1.pos;
}
  | '(' RExp ')'  
{ 
  $$.attr =  $2.attr;
  $$.err = $2.err;
  $$.btype = $2.btype;
  $2.env = $$.env;

  $$.pos = $2.pos;
}

ListRExp : {- empty -} 
{ 
  $$.attr = [];

  $$.err = [];
  $$.paramTypes = [];
}
  | RExp 
{    
  $$.attr = (:[]) $1.attr; 
  $1.env = $$.env;

  $$.err = $1.err;
  $$.paramTypes = [$1.btype]; 
}
  | RExp ',' ListRExp 
{  
  $$.attr = (:) $1.attr $3.attr; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.err = $1.err ++ $3.err;
  $$.paramTypes = $1.btype : $3.paramTypes;
}

RExp1 : RExp2 
{ 
  $$.attr = $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.ident = $1.ident;
  $$.pos = $1.pos;
}

{

data Result = Result Abs.Program [String] deriving (Show)

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}