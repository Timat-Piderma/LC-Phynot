-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParPhynot where

import Prelude

import qualified Env as E
import qualified TypeSystem as TS
import qualified ErrorsBuilder as Err
import qualified AbsPhynot as Abs
import LexPhynot

}

%name pProgram Program
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pStm Stm
%name pListParam ListParam
%name pParam Param
%name pLExp LExp
%name pDim Dim
%name pListDim ListDim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pListRExp ListRExp
%name pRExp1 RExp1
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='          { PT _ (TS _ 1)  }
  '%'           { PT _ (TS _ 2)  }
  '&'           { PT _ (TS _ 3)  }
  '('           { PT _ (TS _ 4)  }
  '()'          { PT _ (TS _ 5)  }
  ')'           { PT _ (TS _ 6)  }
  '*'           { PT _ (TS _ 7)  }
  '+'           { PT _ (TS _ 8)  }
  ','           { PT _ (TS _ 9)  }
  '-'           { PT _ (TS _ 10) }
  '/'           { PT _ (TS _ 11) }
  ';'           { PT _ (TS _ 12) }
  '<'           { PT _ (TS _ 13) }
  '<='          { PT _ (TS _ 14) }
  '='           { PT _ (TS _ 15) }
  '=='          { PT _ (TS _ 16) }
  '>'           { PT _ (TS _ 17) }
  '>='          { PT _ (TS _ 18) }
  'False'       { PT _ (TS _ 19) }
  'None'        { PT _ (TS _ 20) }
  'String'      { PT _ (TS _ 21) }
  'True'        { PT _ (TS _ 22) }
  '['           { PT _ (TS _ 23) }
  ']'           { PT _ (TS _ 24) }
  'and'         { PT _ (TS _ 25) }
  'bool'        { PT _ (TS _ 26) }
  'break'       { PT _ (TS _ 27) }
  'char'        { PT _ (TS _ 28) }
  'continue'    { PT _ (TS _ 29) }
  'def'         { PT _ (TS _ 30) }
  'else'        { PT _ (TS _ 31) }
  'float'       { PT _ (TS _ 32) }
  'if'          { PT _ (TS _ 33) }
  'int'         { PT _ (TS _ 34) }
  'not'         { PT _ (TS _ 35) }
  'or'          { PT _ (TS _ 36) }
  'pass'        { PT _ (TS _ 37) }
  'readChar'    { PT _ (TS _ 38) }
  'readFloat'   { PT _ (TS _ 39) }
  'readInt'     { PT _ (TS _ 40) }
  'readString'  { PT _ (TS _ 41) }
  'return'      { PT _ (TS _ 42) }
  'while'       { PT _ (TS _ 43) }
  'writeChar'   { PT _ (TS _ 44) }
  'writeFloat'  { PT _ (TS _ 45) }
  'writeInt'    { PT _ (TS _ 46) }
  'writeString' { PT _ (TS _ 47) }
  '{'           { PT _ (TS _ 48) }
  '}'           { PT _ (TS _ 49) }
  L_Ident       { PT _ (TV _)    }
  L_charac      { PT _ (TC _)    }
  L_doubl       { PT _ (TD _)   }
  L_integ       { PT _ (TI _)   }
  L_quoted      { PT _ (TL _)   }

%attributetype {Attr a}
%attribute res { Result }
%attribute attr { a }
%attribute err { [String] }
%attribute env { E.EnvT }
%attribute modifiedEnv { E.EnvT }
%attribute ident { String }
%attribute pos { Posn }
%attribute btype { TS.Type }
%attribute arraytype { TS.Type }
%attribute arraydim { Int }
%attribute funcName { String }
%attribute paramTypes { [TS.Type] }

%%

------------------
-- Basic Types  --
------------------

Ident  : L_Ident 
{ 
  $$.attr = Abs.Ident (tokenText $1);
  $$.ident = (tokenText $1);
  $$.err = [];

  $$.pos = (tokenPosn $1);
}

Char     : L_charac 
{ 
  $$.attr =  read (tokenText $1) :: Char;
  $$.err = [];
  $$.btype = (TS.Base TS.CHAR);

  $$.pos = (tokenPosn $1);
 }

Double   : L_doubl  
{ 
  $$.attr = read (tokenText $1) :: Double;
  $$.err = [];
  $$.btype = (TS.Base TS.FLOAT);

  $$.pos = (tokenPosn $1);
}

Integer  : L_integ  
{ 
  $$.attr = read (tokenText $1) :: Integer;
  $$.err = [];
  $$.btype = (TS.Base TS.INT);

  $$.pos = (tokenPosn $1);
}

String   : L_quoted 
{
  $$.attr =  ((\(PT _ (TL s)) -> s) $1);
  $$.err = [];
  $$.btype = (TS.Base TS.STRING);

  $$.pos = (tokenPosn $1);
}

Boolean   : 'True' 
{ 
  $$.attr = Abs.Boolean_True;
  $$.err = [];
  $$.btype = (TS.Base TS.BOOL);
}
| 'False' 
{ 
  $$.attr = Abs.Boolean_False;
  $$.err = [];
  $$.btype = (TS.Base TS.BOOL);
}

BasicType: 'int' 
{ 
  $$.attr = Abs.BasicType_int;
  $$.btype = TS.Base TS.INT;
}
| 'float'   
{ 
  $$.attr = Abs.BasicType_float;
  $$.btype = TS.Base TS.FLOAT;
}
| 'char'   
{ 
  $$.attr = Abs.BasicType_char;
  $$.btype = TS.Base TS.CHAR;
}
| 'String'   
{ 
  $$.attr = Abs.BasicType_String;
  $$.btype = TS.Base TS.STRING;
}
| 'bool'  
{ 
  $$.attr = Abs.BasicType_bool;
  $$.btype = TS.Base TS.BOOL;
}

-------------------
-- Program Start --
-------------------

Program : ListStm 
{ 
  $$.res = Result (Abs.ProgramStart $1.attr) $1.err;
  $1.env = E.emptyEnv;
}

ListStm : Stm ';' 
{ 
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;
  $$.err = $1.err;
} 
| Stm ';' ListStm 
{ 
  $$.attr = (:) $1.attr $3.attr;
  $1.env = $$.env;
  $3.env = $1.modifiedEnv;
  $$.err = $1.err ++ $3.err;
}
------------------
-- Declarations --
------------------

-- Variable Declaration
Stm: BasicType Ident 
{ 
  $$.attr = Abs.VarDeclaration $1.attr $2.attr;
  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkDeclErrs $$.env $2.ident (posLineCol $$.pos); 
  $$.ident = $2.ident;
  $$.pos = $2.pos;
  $$.btype = $1.btype;
}
  | BasicType Ident '=' RExp 
{ 
  $$.attr = Abs.VarDeclarationInit $1.attr $2.attr $4.attr;
  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkDeclInitErrs $$.btype $4.btype $$.env $2.ident (posLineCol $$.pos) ++ $4.err; 
  $$.ident = $2.ident;
  $$.pos = $2.pos;
  $$.btype = $1.btype;
  $4.env = $$.env; 
}
  | BasicType Ident ListDim 
{  
  $$.attr = Abs.ArrayDeclaration $1.attr $2.attr $3.attr;
  $$.modifiedEnv = E.insertArray $2.ident (posLineCol $$.pos) $$.btype $3.arraydim $$.env;
  $$.ident = $2.ident;
  $$.pos = $2.pos;

  $$.btype = (TS.ARRAY $3.btype);
  $3.arraytype = $1.btype;
  $3.env = $$.env;  

  $$.err = Err.mkArrayDeclErrs $$.env $2.ident (posLineCol $$.pos) ++ $3.err;
}
  | BasicType '*' Ident 
{  
  $$.attr = Abs.PointerDeclaration $1.attr $3.attr;
  $$.modifiedEnv = E.insertVar $3.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkDeclErrs $$.env $3.ident (posLineCol $$.pos); 
  $$.ident = $3.ident;
  $$.pos = $3.pos;
  $$.btype = (TS.POINTER $1.btype);
}
  | BasicType '*' Ident '=' RExp 
{  
  $$.attr = Abs.PointerDeclarationInit $1.attr $3.attr $5.attr;
  $$.modifiedEnv = E.insertVar $3.ident (posLineCol $$.pos) $$.btype $$.env;
  $$.err = Err.mkPointerDeclInitErrs $$.btype $5.btype $$.env $3.ident (posLineCol $$.pos) ++ $5.err; 
  $$.ident = $3.ident;
  $$.pos = $3.pos;
  $$.btype = (TS.POINTER $1.btype) ;
  $5.env = $$.env; 
}

---------------
-- Functions --
---------------

  | 'def' BasicType Ident '(' ListParam ')' '{' ListStm '}' 
{  
  $$.attr = Abs.FunctionDeclaration $2.attr $3.attr $5.attr $8.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) $2.btype $5.paramTypes $$.env;
  $8.env = $5.modifiedEnv;
  $5.env = E.insertFunc $3.ident (posLineCol $$.pos) $2.btype $5.paramTypes (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $5.funcName = $3.ident;
  $$.btype = $2.btype;

  $$.err = $5.err ++ (Err.mkFuncDeclErrs $2.btype $$.env $3.ident $5.paramTypes (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $8.err $3.ident);
}
  | 'def' BasicType Ident '()' '{' ListStm '}' 
{  
  $$.attr = Abs.FunctionNoParamDeclaration $2.attr $3.attr $6.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) $2.btype [] $$.env;
  $6.env = E.insertFunc $3.ident (posLineCol $$.pos) $2.btype [] (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $$.btype = $2.btype;

  $$.err = (Err.mkFuncDeclErrs $2.btype $$.env $3.ident [] (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $6.err $3.ident);
}
  | 'def' 'None' Ident '(' ListParam ')' '{' ListStm '}' 
{  
  $$.attr = Abs.ProcedureDeclaration $3.attr $5.attr $8.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) (TS.Base TS.NONE) $5.paramTypes $$.env;
  $8.env = $5.modifiedEnv;
  $5.env = E.insertFunc $3.ident (posLineCol $$.pos) (TS.Base TS.NONE) $5.paramTypes (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $5.funcName = $3.ident;
  $$.btype = (TS.Base TS.NONE);

  $$.err = $5.err ++ (Err.mkFuncDeclErrs (TS.Base TS.NONE) $$.env $3.ident $5.paramTypes (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $8.err $3.ident);
}
  | 'def' 'None' Ident '()' '{' ListStm '}' 
{ 
  $$.attr = Abs.ProcedureNoParamDeclaration $3.attr $6.attr; 

  $$.modifiedEnv = E.insertFunc $3.ident (posLineCol $3.pos) (TS.Base TS.NONE) [] $$.env;
  $6.env = E.insertFunc $3.ident (posLineCol $$.pos) (TS.Base TS.NONE) [] (E.insertVar "return" (posLineCol ($3.pos)) ($$.btype) E.emptyEnv);

  $$.btype = (TS.Base TS.NONE);

  $$.err = (Err.mkFuncDeclErrs (TS.Base TS.NONE) $$.env $3.ident [] (posLineCol ($3.pos))) ++ (Err.prettyFuncErr $6.err $3.ident);
}
  | Ident '(' ListRExp ')' 
{ 
  $$.attr = Abs.ProcedureCall $1.attr $3.attr;
  $3.env = $$.env;

  $$.err = (Err.mkProcedureCallErrs $1.ident $3.paramTypes $$.env (posLineCol $1.pos)) ++ $3.err;
}
  | Ident '()' 
{ 
  $$.attr = Abs.ProcedureCallNoParam $1.attr;
  
  $$.err = (Err.mkProcedureCallErrs $1.ident [] $$.env (posLineCol $1.pos));
}
  | 'return' RExp 
{  
  $$.attr = Abs.Return $2.attr;
  $$.btype = $2.btype;
  $2.env = $$.env;
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkReturnErrs $$.env $2.btype ( posLineCol $$.pos)) ++ $2.err;

  $$.pos = (tokenPosn $1);
}
  | 'return' 
{ 
  $$.attr = Abs.ReturnNone;
  $$.btype = (TS.Base TS.NONE);
  $$.modifiedEnv = $$.env;

  $$.err = (Err.mkReturnErrs $$.env $$.btype ( posLineCol $$.pos));
  $$.pos = (tokenPosn $1);
}

----------------
-- Assignment --
----------------

  | LExp '=' RExp 
{  
  $$.attr = Abs.Assignment $1.attr $3.attr;
  $$.modifiedEnv = $$.env;
  $$.err = Err.mkAssignmentErrs $1.btype $3.btype (posLineCol $1.pos) (posLineCol $3.pos) ++ $1.err ++ $3.err;
  $$.ident = $1.ident;
  $$.pos = $1.pos;
  $$.btype = TS.sup $1.btype $3.btype;
  
  $3.env = $$.env;
  $1.env = $$.env;
}

-----------------------
-- Default Functions --
-----------------------

  | 'writeInt' '(' ')' {  }
  | 'writeFloat' '(' ')' {  }
  | 'writeChar' '(' ')' {   }
  | 'writeString' '(' ')' {   }
  | 'readInt' '()' {  }
  | 'readFloat' '()' {  }
  | 'readChar' '()' {  }
  | 'readString' '()' { }


----------------------
-- Sequence Control --
----------------------

  | 'if' RExp '{' ListStm '}' {   }
  | 'if' RExp '{' ListStm '}' 'else' '{' ListStm '}' {       }
  | 'while' RExp '{' ListStm '}' {   }
  | 'break' {   }
  | 'continue' {   }
  | 'pass' 
{  
  $$.attr = Abs.Pass;
  $$.modifiedEnv = $$.env;
  $$.err = [];
  $$.pos = (tokenPosn $1);
}

ListParam: {- empty -} 
{ 
  $$.attr = []; 
  $$.modifiedEnv = $$.env;
  $$.err = [];

  $$.paramTypes = [];
}
  | Param 
{  
  $$.attr = (:[]) $1.attr; 
  $1.env = $$.env;
  $$.modifiedEnv = $1.modifiedEnv;
  $1.funcName = $$.funcName;
  $$.err = $1.err;

  $$.paramTypes = [$1.btype]; 
}
  | Param ',' ListParam 
{  
  $$.attr = (:) $1.attr $3.attr; 

  $1.env = $$.env;
  $3.env = $1.modifiedEnv;
  $$.modifiedEnv = $3.modifiedEnv;
  $1.funcName = $$.funcName;
  $3.funcName = $$.funcName;

  $$.err = $1.err ++ $3.err;

  $$.paramTypes = $1.btype : $3.paramTypes;
}

Param : BasicType Ident 
{  
  $$.attr = Abs.Parameter $1.attr $2.attr; 

  $$.modifiedEnv = E.insertVar $2.ident (posLineCol $$.pos) $1.btype $$.env;
  $$.pos = $2.pos;

  $$.err = Err.mkParamErrs $2.ident $$.funcName $$.env (posLineCol $$.pos);

  $$.btype = $1.btype;
}

Dim : '[' RExp ']' 
{   
  $$.attr = Abs.ArrayDimension $2.attr; 
  $1.env = $$.env;

  $$.err = if TS.isInt $2.btype
          then $2.err
          else [Err.mkSerr (TS.Base (TS.ERROR ("Array index must be an integer"))) (posLineCol $2.pos)];
}

ListDim : Dim 
{  
  $$.attr = (:[]) $1.attr;
  $1.env = $$.env;


  $$.btype = $$.arraytype;
  $$.arraydim = 1;

  $$.err = $1.err;
} 
| Dim ListDim 
{  
  $$.attr = (:) $1.attr $2.attr; 
  $1.env = $$.env;
  $2.env = $$.env;

  $$.btype = (TS.ARRAY $2.btype);
  $$.arraydim = 1 + $2.arraydim;
  $2.arraytype = $$.arraytype;

  $$.err = $1.err ++ $2.err;
}

----------------------
-- Left Expressions --
----------------------

LExp: Ident 
{
  $$.attr = Abs.LIdent $1.attr;
  $$.ident = $1.ident;
  $$.btype = (E.getVarType $1.ident $$.env);
  $$.pos = $1.pos;

  $$.err = [];
}
  | Ident ListDim 
{  
  $$.attr = Abs.LArray $1.attr $2.attr;
  $$.ident = $1.ident;
  $2.env = $$.env;

  $$.btype = TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) $2.arraydim;
  $2.arraytype = (E.getArrayType $1.ident $$.env);

  $$.err = $2.err;
  $$.pos = $1.pos;
}

-----------------------
-- Right Expressions --
-----------------------

RExp
  : RExp 'or' RExp2 {   }
  | RExp 'and' RExp2 {   }
  | 'not' RExp2 {  }
  | RExp1 
{  
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.pos = $1.pos;
}

RExp2
  : RExp2 '==' RExp3 {  }
  | RExp2 '!=' RExp3 {    }
  | RExp2 '<' RExp3 {    }
  | RExp2 '>' RExp3 {     }
  | RExp2 '<=' RExp3 {    }
  | RExp2 '>=' RExp3 {      }
  | RExp3 
{ 
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.pos = $1.pos;
}

RExp3
  : RExp3 '+' RExp4 {  }
  | RExp3 '-' RExp4 {   }
  | RExp3 '*' RExp4 {     }
  | RExp3 '/' RExp4 {    }
  | RExp3 '%' RExp4 {    }
  | RExp4 
{    
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.pos = $1.pos;
}

RExp4 : '&' RExp5 
{     
  $$.attr = Abs.PointerRef $2.attr; 
  $2.env = $$.env;

  $$.err = $2.err;
  $$.btype = (TS.ADDRESS $2.btype);

  $$.pos = $2.pos;
} 
| RExp5 
{ 
  $$.attr = $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.pos = $1.pos;
}

RExp5
  : Integer 
{ 
  $$.attr = Abs.IntValue $1.attr; 
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.pos = $1.pos;
}
  | Double 
{ 
  $$.attr = Abs.FloatValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.pos = $1.pos;
}
  | String 
{     
  $$.attr = Abs.StringValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype; 

  $$.pos = $1.pos;
}
  | Char 
{  
  $$.attr = Abs.CharValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.pos = $1.pos;
}
  | Boolean 
{  
  $$.attr = Abs.BooleanValue $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;

  $$.pos = $1.pos;
}
  | Ident 
{ 
  $$.attr = Abs.VarValue $1.attr;
  $$.err = $1.err;
  $$.btype = (E.getVarType $1.ident $$.env);

  $$.pos = $1.pos;
}
  | Ident ListDim 
{ 
  $$.attr = Abs.ArrayEntry $1.attr $2.attr; 
  $$.ident = $1.ident;
  $2.env = $$.env;

  $$.btype = TS.getArrayCurrentType (E.getArrayType $1.ident $$.env) $2.arraydim;


  $2.arraytype = (E.getArrayType $1.ident $$.env);

  $$.err = $2.err;
  $$.pos = $1.pos;
}
  | Ident '(' ListRExp ')' 
{  
  $$.attr = Abs.FuncCall $1.attr $3.attr;
  $3.env = $$.env;

  $$.btype = (E.getFuncType $1.ident $$.env);
  $$.err = (Err.mkFuncCallErrs $1.ident $3.paramTypes $$.env (posLineCol $1.pos)) ++ $3.err;

  $$.pos = $1.pos;
}
  | Ident '()' 
{  
  $$.attr = Abs.FuncCallNoParam $1.attr;

  $$.btype = (E.getFuncType $1.ident $$.env);
  $$.err = (Err.mkFuncCallErrs $1.ident [] $$.env (posLineCol $1.pos));

  $$.pos = $1.pos;
}
  | '(' RExp ')'  
{ 
  $$.attr =  $2.attr;
  $$.err = $2.err;
  $$.btype = $2.btype;
  $2.env = $$.env;

  $$.pos = $2.pos;
}

ListRExp : {- empty -} 
{ 
  $$.attr = [];

  $$.err = [];
  $$.paramTypes = [];
}
  | RExp 
{    
  $$.attr = (:[]) $1.attr; 
  $1.env = $$.env;

  $$.err = $1.err;
  $$.paramTypes = [$1.btype]; 
}
  | RExp ',' ListRExp 
{  
  $$.attr = (:) $1.attr $3.attr; 
  $1.env = $$.env;
  $3.env = $$.env;

  $$.err = $1.err ++ $3.err;
  $$.paramTypes = $1.btype : $3.paramTypes;
}

RExp1 : RExp2 
{ 
  $$.attr = $1.attr;
  $$.err = $1.err;
  $$.btype = $1.btype;
  $1.env = $$.env;

  $$.pos = $1.pos;
}

{

data Result = Result Abs.Program [String] deriving (Show)

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}